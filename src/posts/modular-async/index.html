<div>
    <section id="intro">
        <hgroup class="center py1">
            <h2 class="mb1">Modular Async Modeling</h2>
            <span>Sept. 5th, 2024</span>
        </hgroup>
        <p>
        In many modern programming languages, you usually have access to async primitives and general support for asynchronous programming. C++ has coroutines. Go has goroutines (lol). Javascript, Rust, C#, and many others have async/await.
        This is not the case in <a class="bold" href="https://github.com/ziglang/zig/wiki/FAQ#what-is-the-status-of-async-in-zig">Zig</a> where the way to reap the benefits of async modeling is to use an event loop<sup>[1]</sup>.
        </p>

        <p>
        There are a few different implementations in the Zig ecosystem, 
        such as <a class="bold" href="https://github.com/mitchellh/libxev">libxev</a>, <a class="bold" href="https://github.com/Cloudef/zig-aio">zig-aio</a>,
        and the various ones that exist for C<sup>[2][3]</sup> that can be utilized through <code class="language-zig">@cImport</code>.
        For <a class="bold" href="https://github.com/mookums/zzz">zzz</a>, the web server hosting this site, I have rolled my own to achieve very specific goals.
        </p>

        <small>[1]: Some async implementations use event loops under the hood, such as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop">Javascript</a>.</small>
        <br>
        <small>[2]: <a href="https://libuv.org/">libuv</a></small>
        <br>
        <small>[3]: <a href="https://libevent.org/">libevent</a></small>
    </section>

    <section id="modularity">
        <h3>Importance of Modularity</h3>
        <p>
        The design of zzz is tightly coupled with the concept of portability and modularity.
        Functionality that is platform dependent, such as I/O, should support sane defaults for common platforms while also providing methods for swapping in user defined modules.
        </p>
        <p>
        One of my core goals when creating zzz was to have a networking library that operates the same, irrespective of platform.
        This modularity is core for utilization in embedded or bare metal domains where socket abstractions (and apis such as io_uring or iocp) may not exist and you must roll your own functions for handling I/O.
        This means that we must have the ability for the consumer of this library to provide their own asynchronous backends.
        </p>
    </section>

    <section id="event_loop">
        <h3>The Event Loop</h3>
        <p>
        Initally, we want to consider what the core functionality these asynchronous backends need to provide. There are a couple we can immediately consider:
        </p>
        <ul>
            <li>queue accept</li>
            <li>queue recv</li>
            <li>queue send</li>
        </ul>
        <p>
        We must also consider how we interact with all of these queued events:
        </p>
        <ul>
            <li>submit these jobs to be run</li>
            <li>reap the completed jobs to be handled</li>
        </ul>
        <p>
        These functions need to be transparent to the zzz core and they (may) need to each carry their own internal payloads. 
        </p>
        <pre style="max-width: 80vw;">
            <code class="language-zig">
                pub const Completion = struct {
                    context: *anyopaque,
                    result: i32,
                };

                pub const Async = struct {
                    runner: *anyopaque,
                    completions: [256]Completion,

                    _queue_accept: *const fn (self: *Async, context: *anyopaque, socket: Socket) AsyncError!void,
                    _queue_recv: *const fn (self: *Async, context: *anyopaque, socket: Socket, buffer: []u8) AsyncError!void,
                    _queue_send: *const fn (self: *Async, context: *anyopaque, socket: Socket, buffer: []const u8) AsyncError!void,
                    _reap: *const fn (self: *Async) AsyncError![]Completion,
                    _submit: *const fn (self: *Async) AsyncError!void,
                };
            </code>
        </pre>
        <p>
        <i>
        Note: There will be an abstracted <code class="language-zig">Socket</code> type that evaluates at compile time to be the socket of the system or an integer if there isn't one.
        </i>
        </p>
        <p>
        The <code class="language-zig">Async</code> struct is what abstracts every backend passed to zzz.
        It contains a field, <code class="language-zig">runner: *anyopaque</code><sup>[4]</sup>, storing a pointer to whatever the internal implementation uses.
        </p>
        <p>
        It also contains a buffer of 256 <code class="language-zig">Completion</code> structs, each storing a result (<code class="language-zig">i32</code>) and a field,
        <code class="language-zig">context: *anyopaque</code>, for internal implementation use.
        </p>

        <small>[4]: <code class="language-zig">*anyopaque</code> is the same as <code class="language-zig">void*</code> <a href="https://zig.guide/working-with-c/c-primitive-types/">in C</a></small>.
    </section>

    <section id="io_uring">
        <h3>Integrating io_uring</h3>
        <p>
        Now that we have an idea of what we need in our generic <code class="language-zig">Async</code> struct, 
        we can design a backend using my favorite async I/O api, io_uring.
        </p>
        <pre style="max-width: 80vw;">
            <code class="language-zig">
                pub const AsyncIoUring = struct {
                    runner: *anyopaque,
                    completions: [256]Completion,

                    pub fn init(uring: *std.os.linux.IoUring) AsyncIoUring {
                        return AsyncIoUring{
                            .runner = uring,
                            .completions = [_]Completion{undefined} ** 256,
                        };
                    }
                    pub fn queue_accept(self: *Async, context: *anyopaque, socket: std.posix.socket_t) AsyncError!void {
                        const uring: *std.os.linux.IoUring = @ptrCast(@alignCast(self.runner));
                        _ = uring.accept(@as(u64, @intFromPtr(context)), socket, null, null, 0) catch unreachable;
                    }

                    pub fn queue_recv(self: *Async, context: *anyopaque, socket: std.posix.socket_t, buffer: []u8) AsyncError!void {
                        const uring: *std.os.linux.IoUring = @ptrCast(@alignCast(self.runner));
                        _ = uring.recv(@as(u64, @intFromPtr(context)), socket, .{ .buffer = buffer }, 0) catch unreachable;
                    }

                    pub fn queue_send(self: *Async, context: *anyopaque, socket: std.posix.socket_t, buffer: []const u8) AsyncError!void {
                        const uring: *std.os.linux.IoUring = @ptrCast(@alignCast(self.runner));
                        _ = uring.send(@as(u64, @intFromPtr(context)), socket, buffer, 0) catch unreachable;
                    }

                    pub fn submit(self: *Async) AsyncError!void {
                        const uring: *std.os.linux.IoUring = @ptrCast(@alignCast(self.runner));
                        _ = uring.submit() catch unreachable;
                    }

                    pub fn reap(self: *Async) AsyncError![]Completion {
                        const uring: *std.os.linux.IoUring = @ptrCast(@alignCast(self.runner));
                        var cqes: [256]std.os.linux.io_uring_cqe = [_]std.os.linux.io_uring_cqe{undefined} ** 256;
                        const count = uring.copy_cqes(cqes[0..], 1) catch unreachable;

                        const min = @min(self.completions.len, count);

                        for (0..min) |i| {
                            self.completions[i] = Completion{
                                .result = cqes[i].res,
                                .context = @ptrFromInt(@as(usize, @intCast(cqes[i].user_data))),
                            };
                        }

                        return self.completions[0..min];
                    }

                };
            </code>
        </pre>
        <p>The <code class="language-zig">AsyncIoUring</code> implementation stores an instance of a uring in the <code class="language-zig">runner: *anyopaque</code> field,
        allowing for all invocations to have access to this uring.
        This backend can then utilize the functionality provided by the io_uring api to queue network operations.
        </p>
        <p>
        These operations also utilize the <code class="language-zig">context: *anyopaque</code> field from the <code class="language-zig">Completion</code>,
        to attach user data (the internal state of this connection<sup>[5]</sup>) to the completion queue entry.
        <code class="language-zig">submit</code> and <code class="language-zig">reap</code> are self-explainatory, submitting completions or reaping and returning processed ones respectively.
        </p>
        <small>[5]: You can see how it is used later in the <a href="#loop">Core Loop</a> section</small>
        <br>
        <pre style="max-width: 80vw;">
            <code class="language-zig">
                pub fn to_async(self: *AsyncIoUring) Async {
                    return Async{
                        .runner = self.runner,
                        .completions = self.completions,
                        ._queue_accept = queue_accept,
                        ._queue_recv = queue_recv,
                        ._queue_send = queue_send,
                        ._submit = submit,
                        ._reap = reap,
                    };
                }
            </code>
        </pre>
        <p>
        We then provide a method called <code class="language-zig">to_async</code> that just converts this implementation to an <code class="language-zig">Async</code> instance. This implementation will now work with zzz and a variation of this snippet is running and serving this site at the moment.
        </p>
    </section>

    <section id="loop">
        <h3>The Core Loop</h3>
        <p>
        There is an initial preamble that is required for creating the first accept and submitting it to the backend.
        The core loop of zzz works by reaping atleast one completion from the backend, iterating through all of the
        reaped completions, and handling each case appropriately (and likely submitting new actions to the backend).
        </p>
        <pre style="max-width: 80vw">
            <code class="language-zig"> 
                const first = ...;
                _ = try backend.queue_accept(&first, server_socket);
                try backend.submit();

                while (true) {
                    const completions = try backend.reap();
                    const completions_count = completions.len;
                    assert(completions_count > 0);

                    reap_loop: for (completions[0..completions_count]) |completion| {
                        const p: *Provision = @ptrCast(@alignCast(completion.context));

                        switch (p.job) {
                            .Accept => {
                                // Handle Accept...
                            },

                            .Recv => {
                                // Handle Recv...
                            },

                            .Send => {
                                // Handle Send...
                            },
                        }
                    }

                    try backend.submit();
                }
            </code> 
        </pre>
        <p>
        Various implementation details have been omitted for brevity but the philsophy around the core loop remains the same. The <code class="language-zig">Provision</code> type is internal and is not important for this example but remains to highlight how the context field of the <code class="language-zig">Completion</code> is utilized.
        </p>
    </section>
</div>
